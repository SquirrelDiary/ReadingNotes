# HTTP进化史

​	HTTP/0.9：是个相当简单的协议。只有一个方法（GET），没有首部，只能获取 HTML（没有图片只有文本）

​	HTTP/1.0：多了很多功能，首部、错误码、重定向、条件请求等，但仍存在很多瑕疵，尤其不能让多个请求共用一个链接、缺少强制的 HOST 首部、缓存选择也很简陋，这三点影响了 Web 可扩展额方式

​	HTTP/1.1：增加了**缓存相关首部的扩展**，`OPTIONS`方法，`Upgrade`首部，`Range`请求，压缩和传输编码、管线化等功能。因为强制要求客户端提供 HOST 首部，所以**虚拟主机托管**成为可能，也就是在一个 IP 上提供多个 Web 服务。另外使用了`keep-alive`后，Web服务器也不需要在每个响应后关闭连接。这对于提升性能和效率而言意义重大，因为浏览器再也不用为每个请求重新发起 TCP 连接了。

> 缓存相关首部扩展
>
> ​	Entity tag，if-Unmodified-Since，if-Match，if-None-Match等
>
> `OPTIONS`方法：
>
> ​	`OPTIONS`是 HTTP 的一种请求方法，也称**预检请求**。当我们发起一个跨域请求的时候会先发送一个`OPTIONS`请求。它的作用是：
>
> - 检测服务器所支持的请求方法。（比如：‘/user' 路由支持哪些方法： get、post、delete ....）
> - CORS 中的预检请求（检测某个接口是否支持跨域）
>
> `Upgrade`首部：
>
> ​	检测 HTTP 协议及其其他协议是否可使用更高版本的版本进行通信。如果服务器支持 HTTP/2 它将以"101 Switching" 作为回复的状态码，并从此开始在该连接上使用 HTTP/2
>
> `Range`请求：
>
> ​	HTTP 协议范围请求。允许服务器只发送 HTTP 消息的一部分到客户端。运用于传送大的媒体文件（一次请求文档的多个部分），文件下载的断点续传
>
> 压缩和传输编码：`gzip`
>
> 管线化：`Promise.all`批量提交请求
>
> HOST首部：
>
> ​	域名通过解析后获得 IP 找到服务器地址，但是一个服务器上可能会有多个站点，这个时候就需要通过 HOST 找到自己要访问的站点
>
> `keep-alive`：请求连接响应后不会关闭 TCP 连接，加快后续请求启动响应速度

# Web 页面请求

**资源请求流程图：**

![资源请求流程图](C:\Users\renzq\Desktop\ReadingNotes\http\imgs\request.jpg)

流程为：

1. 把请求 URL 放入队列
2. 解析 URL 中域名的 IP 地址
3. 与目标主机建立 TCP 连接
4. 如果是`HTTPS`请求，初始化`TLS`握手
5. 向页面对应的 URL 发送请求

**资源响应流程图：**

![资源响应流程图](C:\Users\renzq\Desktop\ReadingNotes\http\imgs\response.jpg)

流程为：

1. 接受响应请求
2. 如果（接受的）主体是 HTML，那么解析它，并针对页面中的资源触发优先获取机制
3. 如果页面上的关键资源已经接受到，就开始渲染页面
4. 接收其他资源，继续解析渲染，直到结束

页面的每次一次点击，都需要重复上面的流程，给网络带宽和设备资源带来了压力。所以优化的核心就是简化步骤或者去掉某些步骤

# 现实问题

**1.传输资源的大小和数量明显增长，而且这种趋势没有减缓的迹象**

**2.网络延迟。虽然近几年网络带宽增长非常快，但是网络延迟却没有相应的降低。**

# HTTP/1.1存在的问题

**1.线头阻塞**

​	在等待上一个请求响应的同时，发送下一个请求。但是客户端还是按照发送请求的顺序来接受响应。所以当前一个响应缓慢就会影响后续请求，这就是线头阻塞

​	`Promise.all`批量提交请求，但是只能按照发送顺序依次接受请求。如果在请求过程中，如果出现任何情况，就会阻塞后面的请求应答。

**2.低效的 TCP 利用**

​	浏览器最多只能同时创建 6~8 个 TCP 连接。每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，容易造成网络拥堵。TCP 协议只能保证连接正常工作，却不能保证性能最优。（ 传输过程中的暂停）

> **慢启动**
>
> ​	慢启动的设计目的是为了让新连接搞清楚当前网络状况，避免给拥堵的网络添乱。它允许发送者在收到每个确认回复后额外发送 1 个未确认包。这意味着新连接在收到 1 个确认回复后，可以发送 2 个数据包；在收到 2 个确认回复后，可以发 4 个，以此类推。这种几何级数增长很快就可以达到协议规定的发包数上限，这时候连接将进入拥塞避免阶段。这种机制需要几次往返数据请求才能得知最佳拥塞窗口大小。如果发生数据包丢失，连接则会重新进入慢启动阶段。

**3.臃肿的消息首部**

​	消息的首部无法压缩，容易导致客户端到达带宽上限。

**4.受限的优先级设置**

​	浏览器为了请求优先级高的资源，就会推迟其他资源。但是优先级高的资源获取后，在处理的过程中，浏览器并不会发起新的资源请求，所以服务器无法利用这段时间发送优先级低的资源。还有这样的情况：一个高优先级资源被游览器发现，但是受制于浏览器的处理方式，它被排在了一个正在获取的低优先级资源之后

**5.性能优化导致请求内容变大**

​	为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但这导致了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制

# Web性能优化

**1. DNS 查询优化**

**2. 优化 TCP 连接**

**3. 避免重定向**

​	重定向通常触发与额外域名建立连接。一次额外的重定向可能把延迟增加数百毫秒，不利于用户体验，并最终影响到网站的业务上

**4.客户端缓存**

​	将资源缓存到本地。但是因为缓存提前回收或清理而过期就需要重新再获取一次

**5.网络边缘的缓存**

**6.条件缓存**

​	有的时候缓存过去了，但是重新下载的内容和已缓存的内容是一样的。当资源不经常变化时候，使用条件请求可以显著节省带宽和性能

**7.压缩和代码极简化**

​	用 webpack 等工具拼接压缩`js`代码文件

**8.避免阻塞`CSS/JS`**

1. 把`CSS`资源请求放在文档的`heade`标签里

 	2. 清理不需要的`js`
 	3. 通过`async`、`defer`避免阻塞`js`文件加载

**9.图片优化**

1. 裁剪合适的图片大小

 	2. 去掉图片元信息（地理位置信息，时间戳，尺寸和像素信息等）

**10.雪碧图/精灵图**

​	将很多小的图片合成一张大的图片

**11.分片**

​	把服务尽分散在尽可能多的主机上。这样就可以提升 TCP 连接数量。并且将济源分发到不同主机可以不使用 cookies

# HTTP/2协议

## 帧

​	HTTP/2是基于二进制帧的协议，采用分帧是为了将重要信息都分装起来，让协议的解析方可以轻松阅读、解析并还原信息。

**HTTP/2 帧的结构**

![HTTP/2帧的结构](C:\Users\renzq\Desktop\ReadingNotes\http\imgs\farme.jpg)

​	所有帧都是一个固定的 9 字节头部和一个指定长度的负载构成

> Length：表示当前帧的长度
>
> Type：当前帧的类型

​	把一次请求拆分成一系列帧，每个帧都像是填写了完整信息的表单，服务器端接受到这些帧以后可以通过相同的表单信息组合解析成一个完整的请求信息。对比 HTTP/1.1 以文本分隔的方式（一次只能发起处理一个请求和响应，完成之间不能停止解析），这样做就可以让服务器端一次处理多个请求或响应即多路复用。同时每个帧都明确了长度，服务器端处理帧的时候就不会有内存浪费的问题。

## 流

​	流就是一个连接上的一系列通过流ID标识的帧，用来传输一对请求/响应消息。因为分帧，所以可以交错处理请求和响应，而不会互相阻塞。流既可以被客户端/服务器单方面建立和使用，也可以被双方共享，或者被任意一边关闭。在流里面，每一帧发送的顺序非常关键。接受方会按照收到帧的顺序来进行处理。

​	**流的优先级和依赖性**

​	每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。当资源有限的时候，服务器会根据优先级来选择应该发送哪些流。

​	借助 PRIORITY 帧，客户端同样可以告知服务器当前的流依赖于其他那个流。改功能让客户端能建立一个优先级“树”，所有“子流”会依赖于“腹流”的传输完成情况。

​	优先级和依赖关系可以在传输过程中动态的改变

## 流量控制

​	HTTP/2 中每个流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。当到达窗口的负载时，另一端就不被允许发送数据了。

​	只有数据帧会受到流量控制

## 重置

​	HTTP/1.1 中当一个包含 Content-Length 的 HTTP 消息被送出去之后，就很难中断它。通常可以断开整个 TCP 连接，但是会导致需要重新通过三次握手来建立一个新的 TCP 连接。

​	HTTP/2中，可以通过发送`RST_STREAM`帧来终止当前传输的消息并重新发送一个新的，从而避免浪费带宽和中断已有的连接。

## 服务器端推送

​	就是客户端发送了一个获取文档的请求，该文档中包含了一些内嵌图片，JavaScript 文件。服务器端在接受到请求后向客户端推送除了文档以外其他的额外资源。

​	**推送过程**

​	浏览器请求一个 HTML 页面，页面中使用了某个 JavaScript，服务器端在客户端发现这个 JavaScript 链接之前，先构造一个`PUSH_PROMISE`帧告诉客户端有哪些资源将要被推送过来，客户端接收到`PUSH_PROMISE`帧，并选择接受被推送的响应，客户端就不会在发送即将被推送资源的请求。客户端也可以拒收服务器端的推送，常见的情况就是缓存中已经有这个资源了。

>`PUSH_PROMISE`中的属性
>
>`:mehtod`属性：确保请求是安全方法，即幂等的方法（幂等：不管请求多少次，获取到的结果都是一样的）

**服务器推送对比**

![服务器推送对比](C:\Users\renzq\Desktop\ReadingNotes\http\imgs\server-push.jpg)

## 首部压缩

​	HTTP 是一种无状态的协议。简而言之，这意味着每个请求必须要携带服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。这也保证了当一个客户端从一个服务器请求大量资源的时候，这些请求看起来几乎都是一致的。当页面资源个数上升的时候，cookies 和请求的大小都会增加。这些一模一样的东西正好被值得压缩。HTTP/2 通过 HPACK 方式压缩

**参考资料：**

1. [《HTTP/2 基础教程》 阅读摘要](https://juejin.cn/post/6844903822326759438#heading-48)
2. [HTTP/2 详解](https://juejin.cn/post/6844903667569541133#heading-9)
3. [http2-explained-chinese](https://github.com/ye11ow/http2-explained-chinese)



​		

